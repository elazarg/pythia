#
# NUMPY_MODULE = ObjectType('/numpy', frozendict({
#     'ndarray': TYPE[NDARRAY],
#     'array': ARRAY_GEN,
#     'dot': make_function_type(FLOAT, new=False),
#     'zeros': ARRAY_GEN,
#     'ones': ARRAY_GEN,
#     'concatenate': ARRAY_GEN,
#     'empty': ARRAY_GEN,
#     'empty_like': ARRAY_GEN,
#     'full': ARRAY_GEN,
#     'full_like': ARRAY_GEN,
#     'arange': ARRAY_GEN,
#     'linspace': ARRAY_GEN,
#     'logspace': ARRAY_GEN,
#     'geomspace': ARRAY_GEN,
#     'meshgrid': ARRAY_GEN,
#     'max': make_function_type(FLOAT, new=False),
#     'min': make_function_type(FLOAT, new=False),
#     'sum': make_function_type(FLOAT, new=False),
#     'setdiff1d': ARRAY_GEN,
#     'unique': ARRAY_GEN,
#     'append': ARRAY_GEN,
#     'random': ObjectType('/numpy.random', frozendict({
#         'rand': ARRAY_GEN,
#     })),
#     'argmax': make_function_type(INT, new=False),
#     'c_': ObjectType('slice_trick', frozendict({
#         '__getitem__': make_function_type(NDARRAY),
#     })),
#     'r_': ObjectType('slice_trick', frozendict({
#         '__getitem__': make_function_type(NDARRAY),
#     })),
# }))
#
T = TypeVar('T')
Q = TypeVar('Q')
Args = TypeVarTuple('Args')
N = TypeVar('N', Literal[int])

class ndarray:
    @property
    def size(self: ndarray) -> int:...
    @property
    def ndim(self: ndarray) -> int:...
    @property
    def T(self: ndarray) -> ndarray:...
    def __add__(self: ndarray, other: ndarray) -> ndarray: ...
    def __sub__(self: ndarray, other: ndarray) -> ndarray: ...
    def __mul__(self: ndarray, other: ndarray) -> ndarray: ...
    def __truediv__(self: ndarray, other: ndarray) -> ndarray: ...
    def __truediv__(self: ndarray, other: float) -> ndarray: ...

    def __radd__(self, other: float) -> ndarray: ...
    def __rsub__(self, other: float) -> ndarray: ...
    def __rmul__(self, other: float) -> ndarray: ...
    def __rtruediv__(self, other: float) -> ndarray: ...

    def __gt__(self: ndarray, other) -> ndarray: ...
    def __lt__(self: ndarray, other) -> ndarray: ...
    def __getitem__(self: ndarray, key: slice) -> ndarray: ...
    def __getitem__(self: ndarray, key: tuple[*Args]) -> ndarray: ...
    def __getitem__(self: ndarray, key: ndarray) -> ndarray: ...
    def __getitem__(self: ndarray, key: int) -> float: ...
    def __getitem__(self: ndarray, key: list[int]) -> ndarray: ...

    def __iter__(self: ndarray) -> SupportsNext[float]: ...

    def astype(self: ndarray, dtype) -> ndarray: ...

    def mean(self: ndarray) -> ndarray: ...
    def std(self: ndarray) -> float: ...

    @property
    def shape(self: ndarray) -> list[int]: ...
    def any(self: ndarray) -> bool: ...
    def all(self: ndarray) -> bool: ...

    def reshape(self: ndarray, shape: tuple) -> ndarray: ...
    def reshape(self: ndarray, shape: int) -> ndarray: ...

class c_:
    def __getitem__(self: c_, key: slice | tuple[*Args]) -> ndarray: ...

def setdiff1d(a: ndarray, b: ndarray) -> ndarray: ...
def unique(arg: ndarray) -> ndarray: ...
def append(arr: ndarray, value: float) -> ndarray: ...
# def append(arr: ndarray, values: ndarray) -> ndarray: ...

def zeros(dims: tuple) -> ndarray: ...
def zeros(dims: int) -> ndarray: ...
def ones(dims: tuple | int) -> ndarray: ...
def mean(x: ndarray, axis: int) -> ndarray: ...
def dot(x: ndarray, y: ndarray) -> ndarray: ...

def sum(x: ndarray) -> float: ...
def argmin(x: ndarray) -> int: ...
def concatenate(arrays: tuple | ndarray) -> ndarray: ...


class random:
    @new
    def rand(self, dims: tuple) -> ndarray: ...

    @new
    def choice(self, a: ndarray, size: int) -> ndarray: ...
    @new
    def choice(self, a: int, size: int) -> ndarray: ...

class linalg:
    def norm(self, a: ndarray, axis: int) -> ndarray: ...
@new
def array(object) -> ndarray: ...
