from typing import Literal, Iterator

class ndarray[T]:
    _buffer: object  # Shared data buffer for view aliasing

    @property
    def size(self: ndarray[T]) -> int: ...
    @property
    def ndim(self: ndarray[T]) -> int: ...
    @property
    @alias[self._buffer]
    def T(self: ndarray[T]) -> ndarray[T]: ...
    def __bool__(self: ndarray[T]) -> bool: ...
    @new
    def __add__(self: ndarray[T], other: ndarray) -> ndarray[T]: ...
    @new
    def __sub__(self: ndarray[T], other: ndarray) -> ndarray[T]: ...
    @new
    def __mul__(self: ndarray[T], other: ndarray) -> ndarray[T]: ...
    @new
    def __truediv__(self: ndarray[T], other: ndarray) -> ndarray[T]: ...
    @new
    def __truediv__(self: ndarray[T], other: float) -> ndarray[T]: ...
    @new
    def __radd__(self: ndarray[T], other: float) -> ndarray[T]: ...
    @new
    def __rsub__(self: ndarray[T], other: float) -> ndarray[T]: ...
    @new
    def __rmul__(self: ndarray[T], other: float) -> ndarray[T]: ...
    @new
    def __rtruediv__(self: ndarray[T], other: float) -> ndarray[T]: ...
    @new
    def __gt__(self: ndarray[T], other) -> ndarray[T]: ...
    @new
    def __lt__(self: ndarray[T], other) -> ndarray[T]: ...
    @new
    def __ge__(self: ndarray[T], other) -> ndarray[T]: ...
    @new
    def __le__(self: ndarray[T], other) -> ndarray[T]: ...
    @new
    def __eq__(self: ndarray[T], other) -> ndarray[T]: ...
    @new
    def __ne__(self: ndarray[T], other) -> ndarray[T]: ...
    @new
    def __pow__(self: ndarray[T], other: ndarray | float | int) -> ndarray[T]: ...
    @new
    def __matmul__(self: ndarray[T], other: ndarray) -> ndarray[T]: ...
    @alias[self._buffer]
    def __getitem__(self: ndarray[T], key: slice) -> ndarray[T]: ...
    @alias[self._buffer]
    def __getitem__[*Args](self: ndarray[T], key: tuple[*Args]) -> ndarray[T]: ...
    @new
    def __getitem__(self: ndarray[T], key: ndarray) -> ndarray[T]: ...
    @new
    def __getitem__(self: ndarray[T], key: list[int]) -> ndarray[T]: ...
    @new
    def __getitem__(self: ndarray[T], key: int | float) -> T: ...
    @update(ndarray[T])
    def __setitem__(self: ndarray[T], key: int, value: T) -> None: ...
    @update(ndarray[T])
    def __setitem__[*Args](self: ndarray[T], key, value) -> None: ...
    #
    # @new
    # def __iter__(self: ndarray[T]) -> Iterator[T]: ...

    @new
    def astype(self: ndarray[T], dtype: Literal["int"]) -> list[int]: ...
    @new
    def mean(self: ndarray[T]) -> ndarray[T]: ...
    def std(self: ndarray[T]) -> float: ...
    @property
    @new
    def shape(self: ndarray[T]) -> list[int]: ...
    def any(self: ndarray[T]) -> bool: ...
    def all(self: ndarray[T]) -> bool: ...
    @alias[self._buffer]
    def reshape(self: ndarray[T], shape: tuple) -> ndarray[T]: ...
    @alias[self._buffer]
    def reshape(self: ndarray[T], shape: int) -> ndarray[T]: ...
    @alias[self._buffer]
    def reshape(self: ndarray[T], d1: int, d2: int) -> ndarray[T]: ...
    @new
    def mean(self: ndarray[T], axis: int) -> ndarray[T]: ...
    def sum(self: ndarray[T]) -> float: ...
    @new
    def sum(self: ndarray[T], axis: int) -> ndarray[T]: ...
    def argmin(self: ndarray[T]) -> int: ...
    def min(self: ndarray[T]) -> int: ...
    def max(self: ndarray[T]) -> int: ...
    def argmax(self: ndarray[T]) -> int: ...
    @alias[self._buffer]
    def transpose(self: ndarray[T]) -> ndarray[T]: ...
    @new
    def flatten(self: ndarray[T]) -> ndarray[T]: ...
    @alias[self._buffer]
    def ravel(self: ndarray[T]) -> ndarray[T]: ...
    @new
    def clip(self: ndarray[T], a_min: float, a_max: float) -> ndarray[T]: ...
    @update(ndarray[T])
    def fill(self: ndarray[T], value: T) -> None: ...

# class c_:
#     def __getitem__[*Args](self: c_, key: slice | tuple[*Args]) -> ndarray: ...
@property
@new
def c_() -> ndarray[float]: ...
@new
def setdiff1d[T](a: ndarray[T], b: ndarray) -> ndarray[T]: ...
@new
def unique[T](arg: ndarray[T]) -> ndarray[T]: ...
@new
def append[T](arr: ndarray[T], value: T) -> ndarray[T]: ...

# def append(arr: ndarray, values: ndarray) -> ndarray: ...

@new
def zeros(dims: tuple | int) -> ndarray[float]: ...
@new
def zeros(dims: tuple | int, type) -> ndarray[float]: ...
@new
def ones(dims: tuple | int) -> ndarray[float]: ...
@new
def ones(dims: tuple | int, type: Literal["int"]) -> ndarray[int]: ...
@new
def ones(dims: tuple | int, type: Literal["float"]) -> ndarray[float]: ...
@new
def mean(a: ndarray[float], axis: int) -> ndarray[float]: ...
@new
def dot[T](a: ndarray[T], y: ndarray[T]) -> ndarray[T]: ...
def sum[T](a: ndarray[T]) -> T: ...
def argmin[T](a: ndarray[T]) -> int: ...
def argmax[T](a: ndarray[T]) -> int: ...
@new
def concatenate(arrays: tuple | ndarray) -> ndarray[float]: ...
@module
class random:
    @staticmethod
    def seed(seed: int) -> None: ...
    @staticmethod
    @new
    def choice(a: ndarray[float] | int, size: int) -> ndarray[float]: ...
    @staticmethod
    @new
    def rand(*args: int) -> ndarray[float]: ...
    @staticmethod
    @new
    def randn(*args: int) -> ndarray[float]: ...
    @staticmethod
    @new
    def randint(low: int, high: int = None, size: int | tuple = None) -> ndarray[int]: ...
    @staticmethod
    @new
    def random(size: int | tuple = None) -> ndarray[float]: ...
    @staticmethod
    @new
    def normal(
        loc: float = 0.0, scale: float = 1.0, size: int | tuple = None
    ) -> ndarray[float]: ...
    @staticmethod
    @new
    def uniform(
        low: float = 0.0, high: float = 1.0, size: int | tuple = None
    ) -> ndarray[float]: ...
    @staticmethod
    @new
    def permutation[T](x: int | ndarray[T]) -> ndarray[T]: ...
    @staticmethod
    @new
    def shuffle(x: ndarray) -> None: ...

@module
class linalg:
    @staticmethod
    @new
    def norm(a: ndarray[float], ord: None, axis: int) -> ndarray[float]: ...
    @staticmethod
    @new
    def norm(a: ndarray, axis: int) -> ndarray[float]: ...
    @staticmethod
    @new
    def inv(a: ndarray[float]) -> ndarray[float]: ...
    @staticmethod
    @new
    def pinv(a: ndarray[float]) -> ndarray[float]: ...
    @staticmethod
    @new
    def det(a: ndarray[float]) -> float: ...
    @staticmethod
    @new
    def eig(a: ndarray[float]) -> tuple[ndarray[float], ndarray[float]]: ...
    @staticmethod
    @new
    def eigvals(a: ndarray[float]) -> ndarray[float]: ...
    @staticmethod
    @new
    def svd(a: ndarray[float]) -> tuple[ndarray[float], ndarray[float], ndarray[float]]: ...
    @staticmethod
    @new
    def solve(a: ndarray[float], b: ndarray[float]) -> ndarray[float]: ...

@new
def array(object) -> ndarray[float]: ...
@new
def array(object, dtype: Literal["float"]) -> ndarray[float]: ...
@new
def array(object, dtype: Literal["int"]) -> ndarray[int]: ...
@new
def arange(
    start: int | float, stop: int | float = None, step: int | float = 1
) -> ndarray[float]: ...
@new
def linspace(start: float, stop: float, num: int = 50) -> ndarray[float]: ...
@new
def eye(N: int, M: int = None, k: int = 0) -> ndarray[float]: ...
@new
def identity(n: int) -> ndarray[float]: ...
@new
def transpose[T](a: ndarray[T]) -> ndarray[T]: ...
@new
def vstack(tup: tuple | list) -> ndarray[float]: ...
@new
def hstack(tup: tuple | list) -> ndarray[float]: ...
@new
def column_stack(tup: tuple | list) -> ndarray[float]: ...
@new
def where(condition: ndarray[float]) -> ndarray[float]: ...
@new
def where(condition: ndarray[float], x: ndarray[float], y: ndarray[float]) -> ndarray[float]: ...
@new
def where(condition: ndarray, x: int, y: ndarray) -> ndarray[float]: ...
def allclose(a: ndarray[float], b: ndarray[float]) -> bool: ...
def allclose(a: ndarray[float], b: ndarray[float], rtol: float, atol: float) -> bool: ...
def full(shape: tuple | int, fill_value: int, type: Literal["int"]) -> ndarray[int]: ...
def full(shape: tuple | int, fill_value: float | int, type: Literal["float"]) -> ndarray[float]: ...
def std(a: ndarray, axis: int) -> ndarray[float]: ...
